unit HPSOCKET4C;
{ ************************************************************************** }
{ }
{ This C DLL header file first (automatic) conversion generated by: }
{ HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com) }
{ Final Delphi-Jedi (Darth) command-line units edition }
{ }
{ Generated Date:  2013/12/4 }
{ Generated Time: 21:30:56 }
{ Thanks QQ:38829979 }
{ }
{ ************************************************************************** }

interface

uses Windows;

{ +//*********************************************************************** }
{ -名称：连接 ID 数据类型 }
{ -描述：定义连接 ID 的数据类型 }
{ =*********************************************************************** }
type
  HP_CONNID = ULONG_PTR;
  { +//*********************************************************************** }
  { -名称：定义 Socket 对象指针类型别名 }
  { -描述：把 Socket 对象指针定义为更直观的别名 }
  { =*********************************************************************** }
  HP_Object = PVOID;
  HP_Server = HP_Object;
  HP_Client = HP_Object;
  HP_TcpServer = HP_Object;
  HP_TcpClient = HP_Object;
  HP_TcpPullServer = HP_Object;
  HP_TcpPullClient = HP_Object;
  HP_UdpServer = HP_Object;
  HP_UdpClient = HP_Object;
  HP_Listener = HP_Object;
  HP_ServerListener = HP_Object;
  HP_ClientListener = HP_Object;
  HP_TcpServerListener = HP_Object;
  HP_TcpClientListener = HP_Object;
  HP_TcpPullServerListener = HP_Object;
  HP_TcpPullClientListener = HP_Object;
  HP_UdpServerListener = HP_Object;
  HP_UdpClientListener = HP_Object;
  { +//****************************************************************************************************/ }
  { +//******************************************* 公共类、接口********************************************/ }
  { +//****************************************************************************************************/ }
  { +//*********************************************************************** }
  { -名称：通信组件服务状态 }
  { -描述：应用程序可以通过通信组件的 GetState() 方法获取组件当前服务状态 }
  { =*********************************************************************** }
  En_HP_ServiceState = (HP_SS_STARTING = 0, // 正在启动
    HP_SS_STARTED = 1, // 已经启动
    HP_SS_STOPING = 2, // 正在停止
    HP_SS_STOPED = 3 // 已经启动
    );
  { +//*********************************************************************** }
  { -名称：Socket 操作类型 }
  { -描述：应用程序的 OnErrror() 事件中通过该参数标识是哪种操作导致的错误 }
  { =*********************************************************************** }
  En_HP_SocketOperation = (HP_SO_UNKNOWN = 0, // Unknown
    HP_SO_ACCEPT = 1, // Acccept
    HP_SO_CONNECT = 2, // Connnect
    HP_SO_SEND = 3, // Send
    HP_SO_RECEIVE = 4 // Receive
    );
  { +//*********************************************************************** }
  { -名称：事件通知处理结果 }
  { -描述：事件通知的返回值，不同的返回值会影响通信组件的后续行为 }
  { =*********************************************************************** }
  En_HP_HandleResult = (HP_HR_OK = 0, // 成功
    HP_HR_IGNORE = 1, // 忽略
    HP_HR_ERROR = 2 // 错误
    );
  { +//*********************************************************************** }
  { -名称：操作结果代码 }
  { -描述：Start() / Stop() 方法执行失败时，可通过 GetLastError() 获取错误代码 }
  { =*********************************************************************** }
  En_HP_ServerError = (HP_SE_OK = 0, // 成功
    HP_SE_ILLEGAL_STATE = 1, // 当前状态不允许操作
    HP_SE_INVALID_PARAM = 2, // 非法参数
    HP_SE_SOCKET_CREATE = 3, // 创建监听 SOCKET 失败
    HP_SE_SOCKET_BIND = 4, // 绑定监听地址失败
    HP_SE_SOCKET_PREPARE = 5, // 设置监听 SOCKET 失败
    HP_SE_SOCKET_LISTEN = 6, // 启动监听失败
    HP_SE_CP_CREATE = 7, // 创建完成端口失败
    HP_SE_WORKER_THREAD_CREATE = 8, // 创建工作线程失败
    HP_SE_DETECT_THREAD_CREATE = 9, // 创建监测线程失败
    HP_SE_SOCKE_ATTACH_TO_CP = 10 // 监听 SOCKET 绑定到完成端口失败
    );
  { +//***********************************************************************  );
    {-名称：操作结果代码 }
  { -描述：Start() / Stop() 方法执行失败时，可通过 GetLastError() 获取错误代码 }
  { =*********************************************************************** }
  En_HP_ClientError = (HP_CE_OK = 0, // 成功
    HP_CE_ILLEGAL_STATE = 1, // 当前状态不允许操作
    HP_CE_INVALID_PARAM = 2, // 非法参数
    HP_CE_SOCKET_CREATE_FAIL = 3, // 创建 Client Socket 失败
    HP_CE_SOCKET_PREPARE_FAIL = 4, // 设置 Client Socket 失败
    HP_CE_CONNECT_SERVER_FAIL = 5, // 连接服务器失败
    HP_CE_WORKER_CREATE_FAIL = 6, // 创建工作线程失败
    HP_CE_DETECTOR_CREATE_FAIL = 7, // 创建监测线程失败
    HP_CE_NETWORK_ERROR = 8, // 网络错误
    HP_CE_DATA_PROC_ERROR = 9 // 数据处理错误
    );
  { +//***********************************************************************  );
    {-名称：数据抓取结果 }
  { -描述：数据抓取操作的返回值 }
  { =*********************************************************************** }
  En_HP_FetchResult = (HP_FR_OK = 0, // 成功
    HP_FR_LENGTH_TOO_LONG = 1, // 抓取长度过大
    HP_FR_DATA_NOT_FOUND = 2 // 找不到 ConnID 对应的数据
    );
  { +//***************************************************/ }
  { +//************* HPSocket4C.dll 回调函数**************/ }
  { +// 公共回调函数*/ }
  HP_FN_OnSend = function(dwConnID: HP_CONNID; pData: PByte; iLength: Integer)
    : En_HP_HandleResult; stdcall;
  HP_FN_OnReceive = function(dwConnID: HP_CONNID; pData: PByte;
    iLength: Integer): En_HP_HandleResult; stdcall;
  HP_FN_OnPullReceive = function(dwConnID: HP_CONNID; iLength: Integer)
    : En_HP_HandleResult; stdcall;
  HP_FN_OnClose = function(dwConnID: HP_CONNID): En_HP_HandleResult; stdcall;
  HP_FN_OnError = function(dwConnID: HP_CONNID;
    enOperation: En_HP_SocketOperation; iErrorCode: Integer)
    : En_HP_HandleResult; stdcall;
  // 服务端回调函数
  HP_FN_OnPrepareListen = function(soListen: UINT_PTR)
    : En_HP_HandleResult; stdcall;
  HP_FN_OnAccept = function(dwConnID: HP_CONNID; pClient: UINT_PTR)
    : En_HP_HandleResult; stdcall;
  HP_FN_OnServerShutdown = function(): En_HP_HandleResult; stdcall;
  // 客户端回调函数
  HP_FN_OnPrepareConnect = function(dwConnID: HP_CONNID; socket: UINT_PTR)
    : En_HP_HandleResult; stdcall;
  HP_FN_OnConnect = function(dwConnID: HP_CONNID): En_HP_HandleResult; stdcall;

  { +//***************************************************/ }
  { +//************* HPSocket4C.dll 导出函数**************/ }
  { /// 创建 HP_TcpServer 对象 }
var
  Create_HP_TcpServer: function(pListener: HP_TcpServerListener)
    : HP_TcpServer stdcall;

  { /// 创建 HP_TcpClient 对象 }
  Create_HP_TcpClient: function(pListener: HP_TcpClientListener)
    : HP_TcpClient stdcall;

  { /// 创建 HP_TcpPullServer 对象 }
  Create_HP_TcpPullServer: function(pListener: HP_TcpPullServerListener)
    : HP_TcpPullServer stdcall;

  { /// 创建 HP_TcpPullClient 对象 }
  Create_HP_TcpPullClient: function(pListener: HP_TcpPullClientListener)
    : HP_TcpPullClient stdcall;

  { /// 创建 HP_UdpServer 对象 }
  Create_HP_UdpServer: function(pListener: HP_UdpServerListener)
    : HP_UdpServer stdcall;

  { /// 创建 HP_UdpClient 对象 }
  Create_HP_UdpClient: function(pListener: HP_UdpClientListener)
    : HP_UdpClient stdcall;

  { /// 销毁 HP_TcpServer 对象 }
  Destroy_HP_TcpServer: procedure(pServer: HP_TcpServer)stdcall;

  { /// 销毁 HP_TcpClient 对象 }
  Destroy_HP_TcpClient: procedure(pClient: HP_TcpClient)stdcall;

  { /// 销毁 HP_TcpPullServer 对象 }
  Destroy_HP_TcpPullServer: procedure(pServer: HP_TcpPullServer)stdcall;

  { /// 销毁 HP_TcpPullClient 对象 }
  Destroy_HP_TcpPullClient: procedure(pClient: HP_TcpPullClient)stdcall;

  { /// 销毁 HP_UdpServer 对象 }
  Destroy_HP_UdpServer: procedure(pServer: HP_UdpServer)stdcall;

  { /// 销毁 HP_UdpClient 对象 }
  Destroy_HP_UdpClient: procedure(pClient: HP_UdpClient)stdcall;

  { /// 创建 HP_TcpServerListener 对象 }
  Create_HP_TcpServerListener: function: HP_TcpServerListener stdcall;

  { /// 创建 HP_TcpClientListener 对象 }
  Create_HP_TcpClientListener: function: HP_TcpClientListener stdcall;

  { /// 创建 HP_TcpPullServerListener 对象 }
  Create_HP_TcpPullServerListener: function: HP_TcpPullServerListener stdcall;

  { /// 创建 HP_TcpPullClientListener 对象 }
  Create_HP_TcpPullClientListener: function
    : HP_TcpPullClientListener stdcall cdecl;

  { /// 创建 HP_UdpServerListener 对象 }
  Create_HP_UdpServerListener: function: HP_UdpServerListener stdcall;

  { /// 创建 HP_UdpClientListener 对象 }
  Create_HP_UdpClientListener: function: HP_UdpClientListener stdcall;

  { /// 销毁 HP_TcpServerListener 对象 }
  Destroy_HP_TcpServerListener
    : procedure(pListener: HP_TcpServerListener)stdcall;

  { /// 销毁 HP_TcpClientListener 对象 }
  Destroy_HP_TcpClientListener
    : procedure(pListener: HP_TcpClientListener)stdcall;

  { /// 销毁 HP_TcpPullServerListener 对象 }
  Destroy_HP_TcpPullServerListener
    : procedure(pListener: HP_TcpPullServerListener)stdcall;

  { /// 销毁 HP_TcpPullClientListener 对象 }
  Destroy_HP_TcpPullClientListener
    : procedure(pListener: HP_TcpPullClientListener)stdcall;

  { /// 销毁 HP_UdpServerListener 对象 }
  Destroy_HP_UdpServerListener
    : procedure(pListener: HP_UdpServerListener)stdcall;

  { /// 销毁 HP_UdpClientListener 对象 }
  Destroy_HP_UdpClientListener
    : procedure(pListener: HP_UdpClientListener)stdcall;

  { +//*********************************************************************************/ }
  { +//**************************** Server 回调函数设置方法*****************************/ }
  HP_Set_FN_Server_OnPrepareListen: procedure(pListener: HP_ServerListener;
    fn: HP_FN_OnPrepareListen)stdcall;

  HP_Set_FN_Server_OnAccept: procedure(pListener: HP_ServerListener;
    fn: HP_FN_OnAccept)stdcall;

  HP_Set_FN_Server_OnSend: procedure(pListener: HP_ServerListener;
    fn: HP_FN_OnSend)stdcall;

  HP_Set_FN_Server_OnReceive: procedure(pListener: HP_ServerListener;
    fn: HP_FN_OnReceive)stdcall;

  HP_Set_FN_Server_OnPullReceive: procedure(pListener: HP_ServerListener;
    fn: HP_FN_OnPullReceive)stdcall;

  HP_Set_FN_Server_OnClose: procedure(pListener: HP_ServerListener;
    fn: HP_FN_OnClose)stdcall;

  HP_Set_FN_Server_OnError: procedure(pListener: HP_ServerListener;
    fn: HP_FN_OnError)stdcall;

  HP_Set_FN_Server_OnServerShutdown: procedure(pListener: HP_ServerListener;
    fn: HP_FN_OnServerShutdown)stdcall;

  { +//*********************************************************************************/ }
  { +//**************************** Client 回调函数设置方法*****************************/ }
  HP_Set_FN_Client_OnPrepareConnect: procedure(pListener: HP_ClientListener;
    fn: HP_FN_OnPrepareConnect)stdcall;

  HP_Set_FN_Client_OnConnect: procedure(pListener: HP_ClientListener;
    fn: HP_FN_OnConnect)stdcall;

  HP_Set_FN_Client_OnSend: procedure(pListener: HP_ClientListener;
    fn: HP_FN_OnSend)stdcall;

  HP_Set_FN_Client_OnReceive: procedure(pListener: HP_ClientListener;
    fn: HP_FN_OnReceive)stdcall;

  HP_Set_FN_Client_OnPullReceive: procedure(pListener: HP_ClientListener;
    fn: HP_FN_OnPullReceive)stdcall;

  HP_Set_FN_Client_OnClose: procedure(pListener: HP_ClientListener;
    fn: HP_FN_OnClose)stdcall;

  HP_Set_FN_Client_OnError: procedure(pListener: HP_ClientListener;
    fn: HP_FN_OnError)stdcall;

  { +//*************************************************************************/ }
  { +//**************************** Server 操作方法*****************************/ }
  { +// }
  { -* 名称：启动通信组件 }
  { -* 描述：启动服务端通信组件，启动完成后可开始接收客户端连接并收发数据 }
  { -* }
  { -* 参数： pszBindAddress -- 监听地址 }
  { -* usPort -- 监听端口 }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败，可通过 GetLastError() 获取错误代码 }
  { = }
  HP_Server_Start: function(pServer: HP_Server; pszBindAddress: LPCTSTR;
    usPort: USHORT): BOOL stdcall;

  { +// }
  { -* 名称：关闭通信组件 }
  { -* 描述：关闭服务端通信组件，关闭完成后断开所有客户端连接并释放所有资源 }
  { -* }
  { -* 参数： }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败，可通过 GetLastError() 获取错误代码 }
  { = }
  HP_Server_Stop: function(pServer: HP_Server): BOOL stdcall;

  { +// }
  { -* 名称：发送数据 }
  { -* 描述：用户通过该方法向指定客户端发送数据 }
  { -* }
  { -* 参数： dwConnID -- 连接 ID }
  { -* pBuffer -- 发送数据缓冲区 }
  { -* iLength -- 发送数据长度 }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败 }
  { = }
  HP_Server_Send: function(pServer: HP_Server; dwConnID: HP_CONNID;
    const pBuffer: PByte; iLength: Integer): BOOL stdcall;

  { +// }
  { -* 名称：断开连接 }
  { -* 描述：断开与某个客户端的连接 }
  { -* }
  { -* 参数： dwConnID -- 连接 ID }
  { -* bForce -- 是否强制断开连接 }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败 }
  { = }
  HP_Server_Disconnect: function(pServer: HP_Server; dwConnID: HP_CONNID;
    bForce: BOOL): BOOL stdcall;

  { +// }
  { -* 名称：断开超时连接 }
  { -* 描述：断开超过指定时长的连接 }
  { -* }
  { -* 参数： dwPeriod -- 时长（毫秒） }
  { -* bForce -- 是否强制断开连接 }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败 }
  { = }
  HP_Server_DisconnectLongConnections: function(pServer: HP_Server;
    dwPeriod: LongInt; bForce: BOOL): BOOL stdcall;

  { +//*****************************************************************************/ }
  { +//**************************** Server 属性访问方法*****************************/ }
  { +// }
  { -* 名称：设置连接的附加数据 }
  { -* 描述：是否为连接绑定附加数据或者绑定什么样的数据，均由应用程序只身决定 }
  { -* }
  { -* 参数： dwConnID -- 连接 ID }
  { -* pv -- 数据 }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败（无效的连接 ID） }
  { = }
  HP_Server_SetConnectionExtra: function(pServer: HP_Server;
    dwConnID: HP_CONNID; pExtra: PVOID): BOOL stdcall;

  { +// }
  { -* 名称：获取连接的附加数据 }
  { -* 描述：是否为连接绑定附加数据或者绑定什么样的数据，均由应用程序只身决定 }
  { -* }
  { -* 参数： dwConnID -- 连接 ID }
  { -* ppv -- 数据指针 }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败（无效的连接 ID） }
  { = }
  HP_Server_GetConnectionExtra: function(pServer: HP_Server;
    dwConnID: HP_CONNID; ppExtra: PVOID): BOOL stdcall;

  { +// 检查通信组件是否已启动*/ }
  HP_Server_HasStarted: function(pServer: HP_Server): BOOL stdcall;

  { +// 查看通信组件当前状态*/ }
  HP_Server_GetState: function(pServer: HP_Server): En_HP_ServiceState stdcall;

  { +// 获取最近一次失败操作的错误代码*/ }
  HP_Server_GetLastError: function(pServer: HP_Server)
    : En_HP_ServerError stdcall;

  { +// 获取最近一次失败操作的错误描述*/ }
  HP_Server_GetLastErrorDesc: function(pServer: HP_Server): LPCTSTR stdcall;

  { +// 获取客户端连接数*/ }
  HP_Server_GetConnectionCount: function(pServer: HP_Server): DWORD stdcall;

  { +// 获取某个客户端连接时长（毫秒）*/ }
  HP_Server_GetConnectPeriod: function(pServer: HP_Server; dwConnID: HP_CONNID;
    pdwPeriod: PDWORD): BOOL stdcall;

  { +// 获取监听 Socket 的地址信息*/ }
  HP_Server_GetListenAddress: function(pServer: HP_Server; lpszAddress: LPTSTR;
    piAddressLen: PINT; pusPort: PWORD): BOOL stdcall;

  { +// 获取某个客户端连接的地址信息*/ }
  HP_Server_GetClientAddress: function(pServer: HP_Server; dwConnID: HP_CONNID;
    lpszAddress: LPTSTR; piAddressLen: PINT; pusPort: PWORD): BOOL stdcall;

  { +// 设置 Socket 缓存对象锁定时间（毫秒，在锁定期间该 Socket 缓存对象不能被获取使用）*/ }
  HP_Server_SetFreeSocketObjLockTime: procedure(pServer: HP_Server;
    dwFreeSocketObjLockTime: LongInt)stdcall;

  { +// 设置 Socket 缓存池大小（通常设置为平均并发连接数量的 1/3 - 1/2）*/ }
  HP_Server_SetFreeSocketObjPool: procedure(pServer: HP_Server;
    dwFreeSocketObjPool: LongInt)stdcall;

  { +// 设置内存块缓存池大小（通常设置为 Socket 缓存池大小的 2 - 3 倍）*/ }
  HP_Server_SetFreeBufferObjPool: procedure(pServer: HP_Server;
    dwFreeBufferObjPool: LongInt)stdcall;

  { +// 设置 Socket 缓存池回收阀值（通常设置为 Socket 缓存池大小的 3 倍）*/ }
  HP_Server_SetFreeSocketObjHold: procedure(pServer: HP_Server;
    dwFreeSocketObjHold: LongInt)stdcall;

  { +// 设置内存块缓存池回收阀值（通常设置为内存块缓存池大小的 3 倍）*/ }
  HP_Server_SetFreeBufferObjHold: procedure(pServer: HP_Server;
    dwFreeBufferObjHold: LongInt)stdcall;

  { +// 设置工作线程数量（通常设置为 2* CPU + 2）*/ }
  HP_Server_SetWorkerThreadCount: procedure(pServer: HP_Server;
    dwWorkerThreadCount: LongInt)stdcall;

  { +// 设置关闭服务前等待连接关闭的最长时限（毫秒，0 则不等待）*/ }
  HP_Server_SetMaxShutdownWaitTime: procedure(pServer: HP_Server;
    dwMaxShutdownWaitTime: LongInt)stdcall;

  { +// 获取 Socket 缓存对象锁定时间*/ }
  HP_Server_GetFreeSocketObjLockTime: function(pServer: HP_Server)
    : DWORD stdcall;

  { +// 获取 Socket 缓存池大小*/ }
  HP_Server_GetFreeSocketObjPool: function(pServer: HP_Server): DWORD stdcall;

  { +// 获取内存块缓存池大小*/ }
  HP_Server_GetFreeBufferObjPool: function(pServer: HP_Server): DWORD stdcall;

  { +// 获取 Socket 缓存池回收阀值*/ }
  HP_Server_GetFreeSocketObjHold: function(pServer: HP_Server): DWORD stdcall;

  { +// 获取内存块缓存池回收阀值*/ }
  HP_Server_GetFreeBufferObjHold: function(pServer: HP_Server): DWORD stdcall;

  { +// 获取工作线程数量*/ }
  HP_Server_GetWorkerThreadCount: function(pServer: HP_Server): DWORD stdcall;

  { +// 获取关闭服务前等待连接关闭的最长时限*/ }
  HP_Server_GetMaxShutdownWaitTime: function(pServer: HP_Server): DWORD stdcall;

  { +//*********************************************************************************/ }
  { +//**************************** TCP Server 属性访问方法*****************************/ }
  { +// 设置 Accept 预投递 Socket 数量（通常设置为工作线程数的 1 - 2 倍）*/ }
  HP_TcpServer_SetAcceptSocketCount: procedure(pServer: HP_TcpServer;
    dwAcceptSocketCount: LongInt)stdcall;

  { +// 设置通信数据缓冲区大小（根据平均通信数据包大小调整设置，通常设置为 1024 的倍数）*/ }

  HP_TcpServer_SetSocketBufferSize: procedure(pServer: HP_TcpServer;
    dwSocketBufferSize: LongInt)stdcall;

  { +// 设置监听 Socket 的等候队列大小（根据并发连接数量调整设置）*/ }

  HP_TcpServer_SetSocketListenQueue: procedure(pServer: HP_TcpServer;
    dwSocketListenQueue: LongInt)stdcall;

  { +// 设置心跳包间隔（毫秒，0 则不发送心跳包）*/ }

  HP_TcpServer_SetKeepAliveTime: procedure(pServer: HP_TcpServer;
    dwKeepAliveTime: LongInt)stdcall;

  { +// 设置心跳确认包检测间隔（毫秒，0 不发送心跳包，如果超过若干次 [默认：WinXP 5 次, Win7 10 次] 检测不到心跳确认包则认为已断线）*/ }
  HP_TcpServer_SetKeepAliveInterval: procedure(pServer: HP_TcpServer;
    dwKeepAliveInterval: LongInt)stdcall;

  { +// 获取 Accept 预投递 Socket 数量*/ }
  HP_TcpServer_GetAcceptSocketCount: function(pServer: HP_TcpServer)
    : DWORD stdcall;

  { +// 获取通信数据缓冲区大小*/ }
  HP_TcpServer_GetSocketBufferSize: function(pServer: HP_TcpServer)
    : DWORD stdcall;

  { +// 获取监听 Socket 的等候队列大小*/ }
  HP_TcpServer_GetSocketListenQueue: function(pServer: HP_TcpServer)
    : DWORD stdcall;

  { +// 获取心跳检查次数*/ }
  HP_TcpServer_GetKeepAliveTime: function(pServer: HP_TcpServer): DWORD stdcall;

  { +// 获取心跳检查间隔*/ }
  HP_TcpServer_GetKeepAliveInterval: function(pServer: HP_TcpServer)
    : DWORD stdcall;

  { +//*********************************************************************************/ }
  { +//**************************** UDP Server 属性访问方法*****************************/ }
  { +// 设置数据报文最大长度（建议在局域网环境下不超过 1472 字节，在广域网环境下不超过 548 字节）*/ }
  HP_UdpServer_SetMaxDatagramSize: procedure(pServer: HP_UdpServer;
    dwMaxDatagramSize: LongInt)stdcall;

  { +// 获取数据报文最大长度*/ }
  HP_UdpServer_GetMaxDatagramSize: function(pServer: HP_UdpServer)
    : DWORD stdcall;

  { +// 设置监测包尝试次数（0 则不发送监测跳包，如果超过最大尝试次数则认为已断线）*/ }
  HP_UdpServer_SetDetectAttempts: procedure(pServer: HP_UdpServer;
    dwDetectAttempts: LongInt)stdcall;

  { +// 设置监测包发送间隔（秒，0 不发送监测包）*/ }
  HP_UdpServer_SetDetectInterval: procedure(pServer: HP_UdpServer;
    dwDetectInterval: LongInt)stdcall;

  { +// 获取心跳检查次数*/ }
  HP_UdpServer_GetDetectAttempts: function(pServer: HP_UdpServer)
    : DWORD stdcall;

  { +// 获取心跳检查间隔*/ }
  HP_UdpServer_GetDetectInterval: function(pServer: HP_UdpServer)
    : DWORD stdcall;

  { +//*****************************************************************************/ }
  { +//**************************** Client 组件操作方法*****************************/ }
  { +// }
  { -* 名称：启动通信组件 }
  { -* 描述：启动客户端通信组件并连接服务端，启动完成后可开始收发数据 }
  { -* }
  { -* 参数： pszRemoteAddress -- 服务端地址 }
  { -* usPort -- 服务端端口 }
  { -* bAsyncConnect -- 是否采用异步 Connnect }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败，可通过 GetLastError() 获取错误代码 }
  { = }
  HP_Client_Start: function(pClient: HP_Client; pszRemoteAddress: LPCTSTR;
    usPort: USHORT; bAsyncConnect: BOOL): BOOL stdcall;

  { +// }
  { -* 名称：关闭通信组件 }
  { -* 描述：关闭客户端通信组件，关闭完成后断开与服务端的连接并释放所有资源 }
  { -* }
  { -* 参数： }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败，可通过 GetLastError() 获取错误代码 }
  { = }
  HP_Client_Stop: function(pClient: HP_Client): BOOL stdcall;

  { +// }
  { -* 名称：发送数据 }
  { -* 描述：用户通过该方法向服务端发送数据 }
  { -* }
  { -* 参数： dwConnID -- 连接 ID（保留参数，目前该参数并未使用） }
  { -* pBuffer -- 发送数据缓冲区 }
  { -* iLength -- 发送数据长度 }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败，可通过 GetLastError() 获取错误代码 }
  { = }
  HP_Client_Send: function(pClient: HP_Client; dwConnID: HP_CONNID;
    const pBuffer: PByte; iLength: Integer): BOOL stdcall;

  { +//*****************************************************************************/ }
  { +//**************************** Client 属性访问方法*****************************/ }
  { +// 检查通信组件是否已启动*/ }
  HP_Client_HasStarted: function(pClient: HP_Client): BOOL stdcall;

  { +// 查看通信组件当前状态*/ }
  HP_Client_GetState: function(pClient: HP_Client): En_HP_ServiceState stdcall;

  { +// 获取最近一次失败操作的错误代码*/ }
  HP_Client_GetLastError: function(pClient: HP_Client)
    : En_HP_ClientError stdcall;

  { +// 获取最近一次失败操作的错误描述*/ }
  HP_Client_GetLastErrorDesc: function(pClient: HP_Client): LPCTSTR stdcall;

  { +// 获取该组件对象的连接 ID*/ }
  HP_Client_GetConnectionID: function(pClient: HP_Client): HP_CONNID stdcall;

  { +// 获取 Client Socket 的地址信息*/ }
  HP_Client_GetLocalAddress: function(pClient: HP_Client; lpszAddress: LPTSTR;
    piAddressLen: PINT; pusPort: PWORD): BOOL stdcall;

  { +//*********************************************************************************/ }
  { +//**************************** TCP Client 属性访问方法*****************************/ }
  { +// 设置通信数据缓冲区大小（根据平均通信数据包大小调整设置，通常设置为：(N* 1024) - sizeof(TBufferObj)）*/ }
  HP_TcpClient_SetSocketBufferSize: procedure(pClient: HP_TcpClient;
    dwSocketBufferSize: LongInt)stdcall;

  { +// 设置心跳包间隔（毫秒，0 则不发送心跳包）*/ }
  HP_TcpClient_SetKeepAliveTime: procedure(pClient: HP_TcpClient;
    dwKeepAliveTime: LongInt)stdcall;

  { +// 设置心跳确认包检测间隔（毫秒，0 不发送心跳包，如果超过若干次 [默认：WinXP 5 次, Win7 10 次] 检测不到心跳确认包则认为已断线）*/ }
  HP_TcpClient_SetKeepAliveInterval: procedure(pClient: HP_TcpClient;
    dwKeepAliveInterval: LongInt)stdcall;

  { +// 获取通信数据缓冲区大小*/ }
  HP_TcpClient_GetSocketBufferSize: function(pClient: HP_TcpClient)
    : DWORD stdcall;

  { +// 获取心跳检查次数*/ }
  HP_TcpClient_GetKeepAliveTime: function(pClient: HP_TcpClient): DWORD stdcall;

  { +// 获取心跳检查间隔*/ }
  HP_TcpClient_GetKeepAliveInterval: function(pClient: HP_TcpClient)
    : DWORD stdcall;

  { +//*********************************************************************************/ }
  { +//**************************** UDP Client 属性访问方法*****************************/ }
  { +// 设置数据报文最大长度（建议在局域网环境下不超过 1472 字节，在广域网环境下不超过 548 字节）*/ }
  HP_UdpClient_SetMaxDatagramSize: procedure(pClient: HP_UdpClient;
    dwMaxDatagramSize: LongInt)stdcall;

  { +// 获取数据报文最大长度*/ }
  HP_UdpClient_GetMaxDatagramSize: function(pClient: HP_UdpClient)
    : DWORD stdcall;

  { +// 设置监测包尝试次数（0 则不发送监测跳包，如果超过最大尝试次数则认为已断线）*/ }
  HP_UdpClient_SetDetectAttempts: procedure(pClient: HP_UdpClient;
    dwDetectAttempts: LongInt)stdcall;

  { +// 设置监测包发送间隔（秒，0 不发送监测包）*/ }
  HP_UdpClient_SetDetectInterval: procedure(pClient: HP_UdpClient;
    dwDetectInterval: LongInt)stdcall;

  { +// 获取心跳检查次数*/ }
  HP_UdpClient_GetDetectAttempts: function(pClient: HP_UdpClient)
    : DWORD stdcall;

  { +// 获取心跳检查间隔*/ }
  HP_UdpClient_GetDetectInterval: function(pClient: HP_UdpClient)
    : DWORD stdcall;

  { +//**************************************************************************************/ }
  { +//**************************** TCP Pull Server 组件操作方法*****************************/ }
  { +// }
  { -* 名称：抓取数据 }
  { -* 描述：用户通过该方法从 Socket 组件中抓取数据 }
  { -* }
  { -* 参数： dwConnID -- 连接 ID }
  { -* pBuffer -- 数据抓取缓冲区 }
  { -* iLength -- 抓取数据长度 }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败 }
  { = }
  HP_TcpPullServer_Fetch: function(pServer: HP_TcpPullServer;
    dwConnID: HP_CONNID; pBuffer: PByte; iLength: Integer)
    : En_HP_FetchResult stdcall;

  { +//**************************************************************************************/ }
  { +//**************************** TCP Pull Server 属性访问方法*****************************/ }
  { +// 设置 Pull 缓存对象锁定时间（毫秒，在锁定期间该 Pull 缓存对象不能被获取使用）*/ }
  HP_TcpPullServer_SetFreePullBufferLockTime
    : procedure(pServer: HP_TcpPullServer;
    dwFreePullBufferLockTime: LongInt)stdcall;

  { +// 设置 PULL 缓存池大小（通常设置为与 Socket 缓存池大小一致）*/ }
  HP_TcpPullServer_SetFreePullBufferPool: procedure(pServer: HP_TcpPullServer;
    dwFreePullBufferPool: LongInt)stdcall;

  { +// 设置 PULL 缓存池回收阀值（通常设置为与 Socket 缓存池回收阀值一致）*/ }
  HP_TcpPullServer_SetFreePullBufferHold: procedure(pServer: HP_TcpPullServer;
    dwFreePullBufferHold: LongInt)stdcall;

  { +// 获取 Pull 缓存对象锁定时间*/ }
  HP_TcpPullServer_GetFreePullBufferLockTime
    : function(pServer: HP_TcpPullServer): DWORD stdcall;

  { +// 获取 PULL 缓存池大小*/ }
  HP_TcpPullServer_GetFreePullBufferPool: function(pServer: HP_TcpPullServer)
    : DWORD stdcall;

  { +// 获取 PULL 缓存池回收阀值*/ }
  HP_TcpPullServer_GetFreePullBufferHold: function(pServer: HP_TcpPullServer)
    : DWORD stdcall;

  { +//**************************************************************************************/ }
  { +//**************************** TCP Pull Client 组件操作方法*****************************/ }
  { +// }
  { -* 名称：抓取数据 }
  { -* 描述：用户通过该方法从 Socket 组件中抓取数据 }
  { -* }
  { -* 参数： dwConnID -- 连接 ID }
  { -* pBuffer -- 数据抓取缓冲区 }
  { -* iLength -- 抓取数据长度 }
  { -* 返回值： TRUE -- 成功 }
  { -* FALSE -- 失败 }
  { = }
  HP_TcpPullClient_Fetch: function(pClient: HP_TcpPullClient;
    dwConnID: HP_CONNID; pBuffer: PByte; iLength: Integer)
    : En_HP_FetchResult stdcall;

  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    = False;

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;

procedure NewExit; far;
begin
  ExitProc := SaveExit;
  FreeLibrary(DLLHandle)
end { NewExit };

procedure LoadDLL;
begin
  if DLLLoaded then
    Exit;

  DLLHandle := LoadLibrary('HPSocket4C_U.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @Create_HP_TcpServer := GetProcAddress(DLLHandle, 'Create_HP_TcpServer');

    Assert(@Create_HP_TcpServer <> nil);

    @Create_HP_TcpClient := GetProcAddress(DLLHandle, 'Create_HP_TcpClient');

    Assert(@Create_HP_TcpClient <> nil);

    @Create_HP_TcpPullServer := GetProcAddress(DLLHandle,
      'Create_HP_TcpPullServer');

    Assert(@Create_HP_TcpPullServer <> nil);

    @Create_HP_TcpPullClient := GetProcAddress(DLLHandle,
      'Create_HP_TcpPullClient');

    Assert(@Create_HP_TcpPullClient <> nil);

    @Create_HP_UdpServer := GetProcAddress(DLLHandle, 'Create_HP_UdpServer');

    Assert(@Create_HP_UdpServer <> nil);

    @Create_HP_UdpClient := GetProcAddress(DLLHandle, 'Create_HP_UdpClient');

    Assert(@Create_HP_UdpClient <> nil);

    @Destroy_HP_TcpServer := GetProcAddress(DLLHandle, 'Destroy_HP_TcpServer');

    Assert(@Destroy_HP_TcpServer <> nil);

    @Destroy_HP_TcpClient := GetProcAddress(DLLHandle, 'Destroy_HP_TcpClient');

    Assert(@Destroy_HP_TcpClient <> nil);

    @Destroy_HP_TcpPullServer := GetProcAddress(DLLHandle,
      'Destroy_HP_TcpPullServer');

    Assert(@Destroy_HP_TcpPullServer <> nil);

    @Destroy_HP_TcpPullClient := GetProcAddress(DLLHandle,
      'Destroy_HP_TcpPullClient');

    Assert(@Destroy_HP_TcpPullClient <> nil);

    @Destroy_HP_UdpServer := GetProcAddress(DLLHandle, 'Destroy_HP_UdpServer');

    Assert(@Destroy_HP_UdpServer <> nil);

    @Destroy_HP_UdpClient := GetProcAddress(DLLHandle, 'Destroy_HP_UdpClient');

    Assert(@Destroy_HP_UdpClient <> nil);

    @Create_HP_TcpServerListener := GetProcAddress(DLLHandle,
      'Create_HP_TcpServerListener');

    Assert(@Create_HP_TcpServerListener <> nil);

    @Create_HP_TcpClientListener := GetProcAddress(DLLHandle,
      'Create_HP_TcpClientListener');

    Assert(@Create_HP_TcpClientListener <> nil);

    @Create_HP_TcpPullServerListener := GetProcAddress(DLLHandle,
      'Create_HP_TcpPullServerListener');

    Assert(@Create_HP_TcpPullServerListener <> nil);

    @Create_HP_TcpPullClientListener := GetProcAddress(DLLHandle,
      'Create_HP_TcpPullClientListener');

    Assert(@Create_HP_TcpPullClientListener <> nil);

    @Create_HP_UdpServerListener := GetProcAddress(DLLHandle,
      'Create_HP_UdpServerListener');

    Assert(@Create_HP_UdpServerListener <> nil);

    @Create_HP_UdpClientListener := GetProcAddress(DLLHandle,
      'Create_HP_UdpClientListener');

    Assert(@Create_HP_UdpClientListener <> nil);

    @Destroy_HP_TcpServerListener := GetProcAddress(DLLHandle,
      'Destroy_HP_TcpServerListener');

    Assert(@Destroy_HP_TcpServerListener <> nil);

    @Destroy_HP_TcpClientListener := GetProcAddress(DLLHandle,
      'Destroy_HP_TcpClientListener');

    Assert(@Destroy_HP_TcpClientListener <> nil);

    @Destroy_HP_TcpPullServerListener := GetProcAddress(DLLHandle,
      'Destroy_HP_TcpPullServerListener');

    Assert(@Destroy_HP_TcpPullServerListener <> nil);

    @Destroy_HP_TcpPullClientListener := GetProcAddress(DLLHandle,
      'Destroy_HP_TcpPullClientListener');

    Assert(@Destroy_HP_TcpPullClientListener <> nil);

    @Destroy_HP_UdpServerListener := GetProcAddress(DLLHandle,
      'Destroy_HP_UdpServerListener');

    Assert(@Destroy_HP_UdpServerListener <> nil);

    @Destroy_HP_UdpClientListener := GetProcAddress(DLLHandle,
      'Destroy_HP_UdpClientListener');

    Assert(@Destroy_HP_UdpClientListener <> nil);

    @HP_Set_FN_Server_OnPrepareListen := GetProcAddress(DLLHandle,
      'HP_Set_FN_Server_OnPrepareListen');

    Assert(@HP_Set_FN_Server_OnPrepareListen <> nil);

    @HP_Set_FN_Server_OnAccept := GetProcAddress(DLLHandle,
      'HP_Set_FN_Server_OnAccept');

    Assert(@HP_Set_FN_Server_OnAccept <> nil);

    @HP_Set_FN_Server_OnSend := GetProcAddress(DLLHandle,
      'HP_Set_FN_Server_OnSend');

    Assert(@HP_Set_FN_Server_OnSend <> nil);

    @HP_Set_FN_Server_OnReceive := GetProcAddress(DLLHandle,
      'HP_Set_FN_Server_OnReceive');

    Assert(@HP_Set_FN_Server_OnReceive <> nil);

    @HP_Set_FN_Server_OnPullReceive := GetProcAddress(DLLHandle,
      'HP_Set_FN_Server_OnPullReceive');

    Assert(@HP_Set_FN_Server_OnPullReceive <> nil);

    @HP_Set_FN_Server_OnClose := GetProcAddress(DLLHandle,
      'HP_Set_FN_Server_OnClose');

    Assert(@HP_Set_FN_Server_OnClose <> nil);

    @HP_Set_FN_Server_OnError := GetProcAddress(DLLHandle,
      'HP_Set_FN_Server_OnError');

    Assert(@HP_Set_FN_Server_OnError <> nil);

    @HP_Set_FN_Server_OnServerShutdown := GetProcAddress(DLLHandle,
      'HP_Set_FN_Server_OnServerShutdown');

    Assert(@HP_Set_FN_Server_OnServerShutdown <> nil);

    @HP_Set_FN_Client_OnPrepareConnect := GetProcAddress(DLLHandle,
      'HP_Set_FN_Client_OnPrepareConnect');

    Assert(@HP_Set_FN_Client_OnPrepareConnect <> nil);

    @HP_Set_FN_Client_OnConnect := GetProcAddress(DLLHandle,
      'HP_Set_FN_Client_OnConnect');

    Assert(@HP_Set_FN_Client_OnConnect <> nil);

    @HP_Set_FN_Client_OnSend := GetProcAddress(DLLHandle,
      'HP_Set_FN_Client_OnSend');

    Assert(@HP_Set_FN_Client_OnSend <> nil);

    @HP_Set_FN_Client_OnReceive := GetProcAddress(DLLHandle,
      'HP_Set_FN_Client_OnReceive');

    Assert(@HP_Set_FN_Client_OnReceive <> nil);

    @HP_Set_FN_Client_OnPullReceive := GetProcAddress(DLLHandle,
      'HP_Set_FN_Client_OnPullReceive');

    Assert(@HP_Set_FN_Client_OnPullReceive <> nil);

    @HP_Set_FN_Client_OnClose := GetProcAddress(DLLHandle,
      'HP_Set_FN_Client_OnClose');

    Assert(@HP_Set_FN_Client_OnClose <> nil);

    @HP_Set_FN_Client_OnError := GetProcAddress(DLLHandle,
      'HP_Set_FN_Client_OnError');

    Assert(@HP_Set_FN_Client_OnError <> nil);

    @HP_Server_Start := GetProcAddress(DLLHandle, 'HP_Server_Start');

    Assert(@HP_Server_Start <> nil);

    @HP_Server_Stop := GetProcAddress(DLLHandle, 'HP_Server_Stop');

    Assert(@HP_Server_Stop <> nil);

    @HP_Server_Send := GetProcAddress(DLLHandle, 'HP_Server_Send');

    Assert(@HP_Server_Send <> nil);

    @HP_Server_Disconnect := GetProcAddress(DLLHandle, 'HP_Server_Disconnect');

    Assert(@HP_Server_Disconnect <> nil);

    @HP_Server_DisconnectLongConnections := GetProcAddress(DLLHandle,
      'HP_Server_DisconnectLongConnections');

    Assert(@HP_Server_DisconnectLongConnections <> nil);

    @HP_Server_SetConnectionExtra := GetProcAddress(DLLHandle,
      'HP_Server_SetConnectionExtra');

    Assert(@HP_Server_SetConnectionExtra <> nil);

    @HP_Server_GetConnectionExtra := GetProcAddress(DLLHandle,
      'HP_Server_GetConnectionExtra');

    Assert(@HP_Server_GetConnectionExtra <> nil);

    @HP_Server_HasStarted := GetProcAddress(DLLHandle, 'HP_Server_HasStarted');

    Assert(@HP_Server_HasStarted <> nil);

    @HP_Server_GetState := GetProcAddress(DLLHandle, 'HP_Server_GetState');

    Assert(@HP_Server_GetState <> nil);

    @HP_Server_GetLastError := GetProcAddress(DLLHandle,
      'HP_Server_GetLastError');

    Assert(@HP_Server_GetLastError <> nil);

    @HP_Server_GetLastErrorDesc := GetProcAddress(DLLHandle,
      'HP_Server_GetLastErrorDesc');

    Assert(@HP_Server_GetLastErrorDesc <> nil);

    @HP_Server_GetConnectionCount := GetProcAddress(DLLHandle,
      'HP_Server_GetConnectionCount');

    Assert(@HP_Server_GetConnectionCount <> nil);

    @HP_Server_GetConnectPeriod := GetProcAddress(DLLHandle,
      'HP_Server_GetConnectPeriod');

    Assert(@HP_Server_GetConnectPeriod <> nil);

    @HP_Server_GetListenAddress := GetProcAddress(DLLHandle,
      'HP_Server_GetListenAddress');

    Assert(@HP_Server_GetListenAddress <> nil);

    @HP_Server_GetClientAddress := GetProcAddress(DLLHandle,
      'HP_Server_GetClientAddress');

    Assert(@HP_Server_GetClientAddress <> nil);

    @HP_Server_SetFreeSocketObjLockTime := GetProcAddress(DLLHandle,
      'HP_Server_SetFreeSocketObjLockTime');

    Assert(@HP_Server_SetFreeSocketObjLockTime <> nil);

    @HP_Server_SetFreeSocketObjPool := GetProcAddress(DLLHandle,
      'HP_Server_SetFreeSocketObjPool');

    Assert(@HP_Server_SetFreeSocketObjPool <> nil);

    @HP_Server_SetFreeBufferObjPool := GetProcAddress(DLLHandle,
      'HP_Server_SetFreeBufferObjPool');

    Assert(@HP_Server_SetFreeBufferObjPool <> nil);

    @HP_Server_SetFreeSocketObjHold := GetProcAddress(DLLHandle,
      'HP_Server_SetFreeSocketObjHold');

    Assert(@HP_Server_SetFreeSocketObjHold <> nil);

    @HP_Server_SetFreeBufferObjHold := GetProcAddress(DLLHandle,
      'HP_Server_SetFreeBufferObjHold');

    Assert(@HP_Server_SetFreeBufferObjHold <> nil);

    @HP_Server_SetWorkerThreadCount := GetProcAddress(DLLHandle,
      'HP_Server_SetWorkerThreadCount');

    Assert(@HP_Server_SetWorkerThreadCount <> nil);

    @HP_Server_SetMaxShutdownWaitTime := GetProcAddress(DLLHandle,
      'HP_Server_SetMaxShutdownWaitTime');

    Assert(@HP_Server_SetMaxShutdownWaitTime <> nil);

    @HP_Server_GetFreeSocketObjLockTime := GetProcAddress(DLLHandle,
      'HP_Server_GetFreeSocketObjLockTime');

    Assert(@HP_Server_GetFreeSocketObjLockTime <> nil);

    @HP_Server_GetFreeSocketObjPool := GetProcAddress(DLLHandle,
      'HP_Server_GetFreeSocketObjPool');

    Assert(@HP_Server_GetFreeSocketObjPool <> nil);

    @HP_Server_GetFreeBufferObjPool := GetProcAddress(DLLHandle,
      'HP_Server_GetFreeBufferObjPool');

    Assert(@HP_Server_GetFreeBufferObjPool <> nil);

    @HP_Server_GetFreeSocketObjHold := GetProcAddress(DLLHandle,
      'HP_Server_GetFreeSocketObjHold');

    Assert(@HP_Server_GetFreeSocketObjHold <> nil);

    @HP_Server_GetFreeBufferObjHold := GetProcAddress(DLLHandle,
      'HP_Server_GetFreeBufferObjHold');

    Assert(@HP_Server_GetFreeBufferObjHold <> nil);

    @HP_Server_GetWorkerThreadCount := GetProcAddress(DLLHandle,
      'HP_Server_GetWorkerThreadCount');

    Assert(@HP_Server_GetWorkerThreadCount <> nil);

    @HP_Server_GetMaxShutdownWaitTime := GetProcAddress(DLLHandle,
      'HP_Server_GetMaxShutdownWaitTime');

    Assert(@HP_Server_GetMaxShutdownWaitTime <> nil);

    @HP_TcpServer_SetAcceptSocketCount := GetProcAddress(DLLHandle,
      'HP_TcpServer_SetAcceptSocketCount');

    Assert(@HP_TcpServer_SetAcceptSocketCount <> nil);

    @HP_TcpServer_SetSocketBufferSize := GetProcAddress(DLLHandle,
      'HP_TcpServer_SetSocketBufferSize');

    Assert(@HP_TcpServer_SetSocketBufferSize <> nil);

    @HP_TcpServer_SetSocketListenQueue := GetProcAddress(DLLHandle,
      'HP_TcpServer_SetSocketListenQueue');

    Assert(@HP_TcpServer_SetSocketListenQueue <> nil);

    @HP_TcpServer_SetKeepAliveTime := GetProcAddress(DLLHandle,
      'HP_TcpServer_SetKeepAliveTime');

    Assert(@HP_TcpServer_SetKeepAliveTime <> nil);

    @HP_TcpServer_SetKeepAliveInterval := GetProcAddress(DLLHandle,
      'HP_TcpServer_SetKeepAliveInterval');

    Assert(@HP_TcpServer_SetKeepAliveInterval <> nil);

    @HP_TcpServer_GetAcceptSocketCount := GetProcAddress(DLLHandle,
      'HP_TcpServer_GetAcceptSocketCount');

    Assert(@HP_TcpServer_GetAcceptSocketCount <> nil);

    @HP_TcpServer_GetSocketBufferSize := GetProcAddress(DLLHandle,
      'HP_TcpServer_GetSocketBufferSize');

    Assert(@HP_TcpServer_GetSocketBufferSize <> nil);

    @HP_TcpServer_GetSocketListenQueue := GetProcAddress(DLLHandle,
      'HP_TcpServer_GetSocketListenQueue');

    Assert(@HP_TcpServer_GetSocketListenQueue <> nil);

    @HP_TcpServer_GetKeepAliveTime := GetProcAddress(DLLHandle,
      'HP_TcpServer_GetKeepAliveTime');

    Assert(@HP_TcpServer_GetKeepAliveTime <> nil);

    @HP_TcpServer_GetKeepAliveInterval := GetProcAddress(DLLHandle,
      'HP_TcpServer_GetKeepAliveInterval');

    Assert(@HP_TcpServer_GetKeepAliveInterval <> nil);

    @HP_UdpServer_SetMaxDatagramSize := GetProcAddress(DLLHandle,
      'HP_UdpServer_SetMaxDatagramSize');

    Assert(@HP_UdpServer_SetMaxDatagramSize <> nil);

    @HP_UdpServer_GetMaxDatagramSize := GetProcAddress(DLLHandle,
      'HP_UdpServer_GetMaxDatagramSize');

    Assert(@HP_UdpServer_GetMaxDatagramSize <> nil);

    @HP_UdpServer_SetDetectAttempts := GetProcAddress(DLLHandle,
      'HP_UdpServer_SetDetectAttempts');

    Assert(@HP_UdpServer_SetDetectAttempts <> nil);

    @HP_UdpServer_SetDetectInterval := GetProcAddress(DLLHandle,
      'HP_UdpServer_SetDetectInterval');

    Assert(@HP_UdpServer_SetDetectInterval <> nil);

    @HP_UdpServer_GetDetectAttempts := GetProcAddress(DLLHandle,
      'HP_UdpServer_GetDetectAttempts');

    Assert(@HP_UdpServer_GetDetectAttempts <> nil);

    @HP_UdpServer_GetDetectInterval := GetProcAddress(DLLHandle,
      'HP_UdpServer_GetDetectInterval');

    Assert(@HP_UdpServer_GetDetectInterval <> nil);

    @HP_Client_Start := GetProcAddress(DLLHandle, 'HP_Client_Start');

    Assert(@HP_Client_Start <> nil);

    @HP_Client_Stop := GetProcAddress(DLLHandle, 'HP_Client_Stop');

    Assert(@HP_Client_Stop <> nil);

    @HP_Client_Send := GetProcAddress(DLLHandle, 'HP_Client_Send');

    Assert(@HP_Client_Send <> nil);

    @HP_Client_HasStarted := GetProcAddress(DLLHandle, 'HP_Client_HasStarted');

    Assert(@HP_Client_HasStarted <> nil);

    @HP_Client_GetState := GetProcAddress(DLLHandle, 'HP_Client_GetState');

    Assert(@HP_Client_GetState <> nil);

    @HP_Client_GetLastError := GetProcAddress(DLLHandle,
      'HP_Client_GetLastError');

    Assert(@HP_Client_GetLastError <> nil);

    @HP_Client_GetLastErrorDesc := GetProcAddress(DLLHandle,
      'HP_Client_GetLastErrorDesc');

    Assert(@HP_Client_GetLastErrorDesc <> nil);

    @HP_Client_GetConnectionID := GetProcAddress(DLLHandle,
      'HP_Client_GetConnectionID');

    Assert(@HP_Client_GetConnectionID <> nil);

    @HP_Client_GetLocalAddress := GetProcAddress(DLLHandle,
      'HP_Client_GetLocalAddress');

    Assert(@HP_Client_GetLocalAddress <> nil);

    @HP_TcpClient_SetSocketBufferSize := GetProcAddress(DLLHandle,
      'HP_TcpClient_SetSocketBufferSize');

    Assert(@HP_TcpClient_SetSocketBufferSize <> nil);

    @HP_TcpClient_SetKeepAliveTime := GetProcAddress(DLLHandle,
      'HP_TcpClient_SetKeepAliveTime');

    Assert(@HP_TcpClient_SetKeepAliveTime <> nil);

    @HP_TcpClient_SetKeepAliveInterval := GetProcAddress(DLLHandle,
      'HP_TcpClient_SetKeepAliveInterval');

    Assert(@HP_TcpClient_SetKeepAliveInterval <> nil);

    @HP_TcpClient_GetSocketBufferSize := GetProcAddress(DLLHandle,
      'HP_TcpClient_GetSocketBufferSize');

    Assert(@HP_TcpClient_GetSocketBufferSize <> nil);

    @HP_TcpClient_GetKeepAliveTime := GetProcAddress(DLLHandle,
      'HP_TcpClient_GetKeepAliveTime');

    Assert(@HP_TcpClient_GetKeepAliveTime <> nil);

    @HP_TcpClient_GetKeepAliveInterval := GetProcAddress(DLLHandle,
      'HP_TcpClient_GetKeepAliveInterval');

    Assert(@HP_TcpClient_GetKeepAliveInterval <> nil);

    @HP_UdpClient_SetMaxDatagramSize := GetProcAddress(DLLHandle,
      'HP_UdpClient_SetMaxDatagramSize');

    Assert(@HP_UdpClient_SetMaxDatagramSize <> nil);

    @HP_UdpClient_GetMaxDatagramSize := GetProcAddress(DLLHandle,
      'HP_UdpClient_GetMaxDatagramSize');

    Assert(@HP_UdpClient_GetMaxDatagramSize <> nil);

    @HP_UdpClient_SetDetectAttempts := GetProcAddress(DLLHandle,
      'HP_UdpClient_SetDetectAttempts');

    Assert(@HP_UdpClient_SetDetectAttempts <> nil);

    @HP_UdpClient_SetDetectInterval := GetProcAddress(DLLHandle,
      'HP_UdpClient_SetDetectInterval');

    Assert(@HP_UdpClient_SetDetectInterval <> nil);

    @HP_UdpClient_GetDetectAttempts := GetProcAddress(DLLHandle,
      'HP_UdpClient_GetDetectAttempts');

    Assert(@HP_UdpClient_GetDetectAttempts <> nil);

    @HP_UdpClient_GetDetectInterval := GetProcAddress(DLLHandle,
      'HP_UdpClient_GetDetectInterval');

    Assert(@HP_UdpClient_GetDetectInterval <> nil);

    @HP_TcpPullServer_Fetch := GetProcAddress(DLLHandle,
      'HP_TcpPullServer_Fetch');

    Assert(@HP_TcpPullServer_Fetch <> nil);

    @HP_TcpPullServer_SetFreePullBufferLockTime :=
      GetProcAddress(DLLHandle, 'HP_TcpPullServer_SetFreePullBufferLockTime');

    Assert(@HP_TcpPullServer_SetFreePullBufferLockTime <> nil);

    @HP_TcpPullServer_SetFreePullBufferPool :=
      GetProcAddress(DLLHandle, 'HP_TcpPullServer_SetFreePullBufferPool');

    Assert(@HP_TcpPullServer_SetFreePullBufferPool <> nil);

    @HP_TcpPullServer_SetFreePullBufferHold :=
      GetProcAddress(DLLHandle, 'HP_TcpPullServer_SetFreePullBufferHold');

    Assert(@HP_TcpPullServer_SetFreePullBufferHold <> nil);

    @HP_TcpPullServer_GetFreePullBufferLockTime :=
      GetProcAddress(DLLHandle, 'HP_TcpPullServer_GetFreePullBufferLockTime');

    Assert(@HP_TcpPullServer_GetFreePullBufferLockTime <> nil);

    @HP_TcpPullServer_GetFreePullBufferPool :=
      GetProcAddress(DLLHandle, 'HP_TcpPullServer_GetFreePullBufferPool');

    Assert(@HP_TcpPullServer_GetFreePullBufferPool <> nil);

    @HP_TcpPullServer_GetFreePullBufferHold :=
      GetProcAddress(DLLHandle, 'HP_TcpPullServer_GetFreePullBufferHold');

    Assert(@HP_TcpPullServer_GetFreePullBufferHold <> nil);

    @HP_TcpPullClient_Fetch := GetProcAddress(DLLHandle,
      'HP_TcpPullClient_Fetch');

    Assert(@HP_TcpPullClient_Fetch <> nil);

  end
  else
  begin
    DLLLoaded := False;
    { Error: HPSOCKET4C.DLL could not be loaded !! }
  end;

end { LoadDLL };

begin
  LoadDLL;

end.
